---
title: "GitHub Actions for Automating Scientific Workflows"
author: "Eric R. Scott"
date: "2024-12-04"
date-format: long
format: 
  uaz-revealjs:
    theme:
      - custom.scss
logo: logo.png
---

## Workshop Links

-   [These slides](https://cct-datascience.quarto.pub/github-actions-for-automating-scientific-workflows/#/title-slide)

-   [GitHub Repository](https://github.com/cct-datascience/github-actions-for-research)

. . .

### Acknowledgments:

-   Heavily inspired by Workshop delivered at US-RSE by Valentina Staneva, Quinn (George) Brencher, and Scott Henderson ([slides](https://docs.google.com/presentation/d/1brXVUg-1e8_XxfYxGMWciB5UCtqXhDtocSV3WR5m49w/edit#slide=id.g24aa3036f10_0_214), [repo](https://github.com/uwescience/GitHubActionsTutorial-USRSE24), [documentation](https://githubactionstutorial-usrse24.readthedocs.io/en/latest/intro.html)).

## Learning Objectives

-   Understand the role of GitHub Actions workflows in (research) software development

-   Know how to trigger workflows in several different ways and determine which trigger is useful for different scientific applications

-   Be able to export and access data created by workflows in a variety of ways

-   Use GitHub actions for distributed computing

## Vocabulary

-   **git**: version control program for tracking and managing changes in files

-   **Repository**: a folder, tracked by git, with your code and data in it

-   **GitHub**: a cloud platform for syncing git repositories, publishing websites, running automated workflows (this workshop), and more

## What is GitHub Actions?

::: incremental
-   Run basically any workflow on a virtual machine(s) in the cloud in a way that integrates with GitHub

-   Easily incorporate workflows for common, complex tasks created by others

-   Designed for continuous integration & delivery (CI/CD)—software development practices that translate to scientific code and data.
:::

## Continuous Integration

-   Automate integrating changes in code or data into the main version of your project in a safe way.
    For example:

    -   When data is updated, run some data validation checks

    -   Before incorporating changes from a collaborator, make sure their code adheres to a particular style

## Continuous Delivery

-   "Delivery" is basically any way you make your data, code, or code outputs available to view or download.
    For example:

    -   Every month, archive a new version of the data with Zenodo and get a new DOI

    -   When code or data is updated, re-render a report for collaborators

## Workshop setup

1.  Go to [template repository](https://github.com/cct-datascience/github-actions-for-research)

2.  Click the green "Use this template" button and select "create new repository"

    ![](images/use_template.png)

3.  For "Owner" choose your own GitHub username and choose a repository name (e.g. "github-actions-workshop").
    **Important: make the repository public!**

## Run your first action

In the "Actions" tab, find the "hello_world" example and click "Run workflow"

![](images/run_workflow.png)

## Workflow components

``` {.yml code-line-numbers="|1-3|4-5|6|7-14|8|10-11|13-14|"}
on: 
  workflow_dispatch

jobs:
  hello-world:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup R 
        uses: r-lib/actions/setup-r@v2 #installs R
      
      - name: Run my code
        run: Rscript mycode.R 
```

::: notes
1.  Triggering event(s) = workflow_dispatch
2.  Jobs, in this case only one—`hello-world`
3.  Runner for the job, in this case `ubuntu-latest`
4.  Steps to run sequentially on that runner
5.  actions/checkout is an "action"---pre-packaged re-usable workflow. This one gets the contents of your repository
6.  Another "action". This one installs R
7.  Running a shell command, in this case, source the mycode.R script
:::

## Hello World example {.smaller}

``` yaml
on:
  workflow_dispatch

name: "01-Hello World!"

jobs:
  hello-world:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup R 
        uses: r-lib/actions/setup-r@v2 #installs R
      
      # the `Rscript` shell command runs an R script.  With the `-e` flag it runs an R expression
      - name: Install R packages
        run: |
          Rscript -e "install.packages('cowsay')" 
        
      - name: Say Hello
        run: |
          Rscript R/hello.R
```

## Workflow components: events

Workflows are triggered by **events** that occur in your GitHub repository:

-   `push`: triggered whenever changes are made to your repository

-   `pull_request`: runs on a "pull request"—a common way of making changes to a repository

-   `workflow dispatch`: creates a "run workflow" button that you can click on GitHub

-   `schedule`: E.g. run on the first Monday of every month.

## Workflow components: runners

Workflows contain one or more **jobs** that run on virtual machines, called runners.

You can use these GitHub provided runners for free

| Virtual Machine | CPU Cores | RAM   | Storage |
|-----------------|-----------|-------|---------|
| Ubuntu Linux    | 4         | 16 GB | 14 GB   |
| Windows         | 4         | 16 GB | 14 GB   |
| macOS (M1)      | 3         | 7 GB  | 14 GB   |

## Workflow components: jobs {.smaller}

Each **job** may contain multiple **steps**.
**Steps** can be either run a script or an **action**.

```{mermaid}
%%| fig-align: center
%%| fig-height: 2
%%{init:{'flowchart':{'nodeSpacing': 15, 'rankSpacing': 10}}}%%
flowchart TD
    c["Event"]-->ubuntu
    c --> mac
        subgraph ubuntu [runs-on: ubuntu-latest]
        subgraph Job 1
            direction TB
            a1["Step 1: Checkout"]--> a2["Step 2: Install R"]
            a2--> a3["Step 3: Run R Script"]
        end
        end
        subgraph mac [runs-on: macos-latest]
        subgraph Job 2
            direction TB
            b1["Step 1: Checkout"]--> b2["Step 2: Install Python"]
            b2--> b3["Step 3: Run Python Script"]
        end
        end
```

## Workflow components: actions

Pre-packaged workflows for common complex tasks.

Common actions:

-   [actions/checkout](https://github.com/actions/checkout): almost every workflow starts with this—it gets the files in your repository onto the runner

-   [r-lib/actions/setup-r](https://github.com/r-lib/actions/tree/v2-branch/setup-r): installs a specified version of R

-   [actions/setup-python](https://github.com/actions/setup-python): installs a specified version of Python

-   [r-lib/actions/setup-renv](https://github.com/r-lib/actions/tree/v2-branch/setup-renv): if your project uses `renv`, it will install the R packages in the `renv.lock` file in your repository

## Workflow components: variables

-   Environment variables can be set in workflows with

    ``` {.yaml filename="action.yaml"}
    env:
      VARIABLE_NAME: "variable"
    ```

    and accessed in R code with

    ``` {.r filename="script.R"}
    Sys.getenv("VARIABLE_NAME")
    ```

-   Secrets can be stored in GitHub and accessed in workflows with

    ``` {.yaml filename="action.yaml"}
    key: ${{ secrets.SECRET_VAR }}
    ```

## Matrix variables

Matrix variables can be used for iteration to spawn parallel runners.

``` {.yaml filename="action.yaml"}
jobs:
  myjob:
    strategy:
      matrix:
        letters: ["A", "B", "C"]
    runs-on: ubuntu-latest
    steps:
      - name: Setup R
        uses: r-lib/actions/setup-r@v2
      - name: Print letters
        run: Rscript -e "print(Sys.getenv('ALPHABET'))"
        env:
          ALPHABET: ${{ matrix.letters }}
```

## Example: data validation script

`validate.yaml`

-   Runs `R/validate.R` which either errors or doesn't
-   Pros: simple
-   Cons: fails fast (only the *first* error is reported)

## Example: data validation tests

`testthat.yaml`

-   Runs `testthat.R` which uses the `testthat` R package

-   Pros: all tests are run even with multiple errors

-   Cons: more complicated setup, `testthat` is usually for R *packages*

## Example: rendering a report to markdown

`render_readme.yaml`

-   Renders a .Qmd (Quarto) file to "github flavored markdown" which is rendered into html by GitHub

-   Pros: relatively simple with `quarto-actions/render` action

-   Cons: must commit results in order to see them—could cause git confusion!
    GFM doesn't support all Quarto HTML features

## Example: rendering a report to GitHub pages

`validation_report.yaml`

-   Renders a validation report to a webpage served on GitHub

-   Pros: all Quarto HTML features supported, full-fledged website you can send to your collaborators

-   Cons: must run `quarto publish gh-pages` locally once before the action works

## Example: parallel computing

`matrix.yaml`

-   Uses the `matrix:` key to iterate over multiple weather stations, pull data, fit a model, and combine model summaries

-   Pros: Scheduling a task like this is easier on GitHub actions than, say, the HPC

-   Cons: Limitations on number of concurrent runners and computational power of runners

## Resources

-   [GitHub Actions documentation](https://docs.github.com/en/actions)

-   [Actions marketplace](https://github.com/marketplace?type=actions)

-   US-RSE '24 tutorial: [GitHub Actions for Scientific Data Workflows](https://githubactionstutorial-usrse24.readthedocs.io/en/latest/intro.html)

## CCT Data Science

-   Virtual [drop-in hours](https://datascience.cct.arizona.edu/drop-in-hours) every Wednesday from 2-3pm

-   [Data science incubator](https://datascience.cct.arizona.edu/incubator)

-   Join our [email list](https://forms-a.trellis.arizona.edu/f/CampaignSubscription?tfa_4=7016R000001VAlU)
